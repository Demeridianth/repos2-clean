"""lambda"""

# lambda functions = anonymous function
def add(x, y):
    return x + y

a = lambda x, y: x + y

# print((lambda x, y: x + y)(4, 5))
    

#cubed in different ways
nums = [3, 4, 5, 6, 7]

def my_map(my_func, my_iter):
    result = []
    for item in my_iter:
        new_item = my_func(item)
        result.append(new_item)
    return result

def in_cube(x):
    return x**3

mapp = list(map(in_cube, nums))

# with lambda
cubed = my_map(lambda x: x**3, nums)
# my_map is a "higher order" function for lamda in this case


######################################


# identity function, a function that returns its argument
def identity(x):
    return x

# in contrast: lambda
lambda x: x

# keyword: lambda
# bound variable (argument): x
# body: x


lambda x: x + 1

# applying the function above to an argument
(lambda x: x + 1)(2)
# 3


full_name = lambda first, last: f'Full name: {first.title()} {last.title()}'
# title() method returns a string where the first character in every word is upper case

full_name('guido', 'van rossum')
# 'Full name: Guido Van Rossum'

lambda x, y: x + y


# higher order function
high_ord_func = lambda x, func: x + func(x)
high_ord_func(2, lambda x: x * x)
# 6

high_ord_func(2, lambda x: x + 3)
# 7


import dis
# The dis module exposes functions to analyze Python bytecode generated by the Python compiler

add = lambda x, y: x + y
type(add)
# <class 'function'>
dis.dis(add)
# 75            0 LOAD_FAST                0 (x)
#               2 LOAD_FAST                1 (y)
#               4 BINARY_ADD
#               6
# RETURN_VALUE

# add
# <function <lambda> at 0x7f5f2ab33ca0>


def add(x, y): return x + y
type(add)
# <class 'function'>
dis.dis(add)
#  75           0 LOAD_FAST                0 (x)
#               2 LOAD_FAST                1 (y)
#               4 BINARY_ADD
#               6
# RETURN_VALUE

# add
# <function add at 0x7f6
#1f86
#f21f0>


# it is possible to write lamda on 2 lines but only and USING PARANTHESIS as a single expression
odd_even = (lambda x:
x % 2 and 'odd' or 'even')(3)

def odd(x):
    return x % 2 and 'odd' or 'even'



# options to pass arguments to lambda expressions:




(lambda x, y, z: x + y + z)(1, 2, 3)
# 6
(lambda x, y, z=3: x + y + z)(1, 2)
# 6
(lambda x, y, z=3: x + y + z)(1, y=2)
# 6
(lambda *args: sum(args))(1,2,3)
# 6
(lambda **kwargs: sum(kwargs.values()))(one=1, two=2, three=3)
# 6
(lambda x, *, y=0, z=0: x + y + z)(1, y=2, z=3)
# 6



# decorator
def my_decorator(f):
    def wraps(*args):
        print(f'Calling function "{f.__name__}"')
        return f(args)
    return wraps

@my_decorator
def decorated_function(x):
    print(f'With argument "{x}"')

decorated_function('1')


# decorator applied to a lambda, (it is impossible to apply it through @decorator syntax, but it can be called as a function)

# defining decorator
def trace(f):
    def wrap(x, y):
        print(f"[TRACE] func: {f.__name__}, args: {x}, kwargs: {y}")
        return f(x, y)
    return wrap

# applying decorator to a function
@trace
def add_two(x, y):
    return x + y + 2

# calling the decorated function
add_two(3, 4)

# applying decorator to lambda
print(trace(lambda x, y: x ** 2 + y)(3, 4))









    

    